import { GoogleGenAI, Modality, Type } from "@google/genai";
import { AspectRatio } from "../types";

const API_KEY = process.env.API_KEY;

if (!API_KEY) {
  // This is a fallback for development and will show an error in the UI.
  // In a real deployed environment, process.env.API_KEY should be set.
  console.error("API_KEY is not set in environment variables.");
}

const ai = new GoogleGenAI({ apiKey: API_KEY });

export const generateImage = async (prompt: string, aspectRatio: AspectRatio): Promise<string> => {
  if (!API_KEY) {
    throw new Error("Gemini API key is not configured. Please set the API_KEY environment variable.");
  }
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: {
        parts: [
          {
            text: `A high-quality, cinematic photo of: ${prompt}. Aspect ratio: ${aspectRatio}.`,
          },
        ],
      },
      config: {
          responseModalities: [Modality.IMAGE],
      },
    });

    for (const part of response.candidates[0].content.parts) {
      if (part.inlineData) {
        const base64ImageBytes: string = part.inlineData.data;
        return `data:${part.inlineData.mimeType};base64,${base64ImageBytes}`;
      }
    }
    
    throw new Error("No image was generated by the API.");
  } catch (error) {
    console.error("Error calling Gemini API:", error);
    throw new Error("Failed to generate image with Gemini API. Please check the console for details.");
  }
};

export const generateVideo = async (prompt: string, aspectRatio: AspectRatio, onProgress: (message: string) => void): Promise<string> => {
  // Veo needs its own API key selection flow
  if (!(window as any).aistudio?.hasSelectedApiKey || !(window as any).aistudio?.openSelectKey) {
      throw new Error("AI Studio context is not available to select an API key for video generation.");
  }

  const hasApiKey = await (window as any).aistudio.hasSelectedApiKey();
  if (!hasApiKey) {
      onProgress('Please select an API key to use Veo.');
      await (window as any).aistudio.openSelectKey();
      // After openSelectKey, we can assume a key is available for the next call.
  }
  
  onProgress('Initializing video generation...');
  
  // Create a new client to ensure the latest key from the dialog is used.
  const veoAi = new GoogleGenAI({ apiKey: process.env.API_KEY });
  
  const veoAspectRatio = (aspectRatio === '9:16') ? '9:16' : '16:9';

  try {
      let operation = await veoAi.models.generateVideos({
          model: 'veo-3.1-fast-generate-preview',
          prompt: `A high-quality, cinematic video of: ${prompt}.`,
          config: {
              numberOfVideos: 1,
              resolution: '720p',
              aspectRatio: veoAspectRatio
          }
      });

      const messages = [
          "Warming up the pixels...",
          "Choreographing digital actors...",
          "Rendering epic scenes...",
          "Just a moment, magic is happening...",
          "Composing the final cut..."
      ];
      let messageIndex = 0;
      onProgress(messages[messageIndex]);

      while (!operation.done) {
          // Wait 10 seconds before polling again
          await new Promise(resolve => setTimeout(resolve, 10000));
          messageIndex = (messageIndex + 1) % messages.length;
          onProgress(messages[messageIndex]);
          
          if (!operation) {
            throw new Error("Operation status is missing, cannot poll for status.");
          }

          const pollingAi = new GoogleGenAI({ apiKey: process.env.API_KEY });
          operation = await pollingAi.operations.getVideosOperation({ operation });
      }
      
      // Add a final check for the response, as it might not be immediately available when 'done' is true.
      if (operation.done && !operation.response?.generatedVideos?.[0]?.video?.uri && !operation.error) {
          onProgress("Finalizing results...");
          await new Promise(resolve => setTimeout(resolve, 5000)); // wait 5 more seconds
          const finalCheckAi = new GoogleGenAI({ apiKey: process.env.API_KEY });
          operation = await finalCheckAi.operations.getVideosOperation({ operation });
      }

      if (operation.error) {
          const errorMessage = operation.error.message || 'Video generation failed with an unknown error.';
          throw new Error(`Video generation failed: ${errorMessage}`);
      }

      const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;
      if (!downloadLink) {
          throw new Error("Video generation completed, but no download link was found.");
      }
      
      onProgress('Fetching generated video...');
      const apiKey = process.env.API_KEY;
      if (!apiKey) {
          throw new Error("API key disappeared after selection. Please try again.");
      }

      const response = await fetch(`${downloadLink}&key=${apiKey}`);
      if (!response.ok) {
          if (response.status === 404 || response.status === 400) {
               throw new Error("API key may be invalid or lack permissions. Please try generating again and select a different key. For more info, see ai.google.dev/gemini-api/docs/billing");
          }
          throw new Error(`Failed to download video file: ${response.statusText}`);
      }

      const blob = await response.blob();
      return URL.createObjectURL(blob);
  } catch (error) {
      if (error instanceof Error) {
          if (error.message.includes("Requested entity was not found.")) {
               throw new Error("API key validation failed. Please try generating again and select a valid API key. For more info on billing, visit ai.google.dev/gemini-api/docs/billing");
          }
          throw error;
      }
      console.error("Unknown error during video generation:", error);
      throw new Error("An unknown error occurred while generating video.");
  }
};

/**
 * Generates a visual prompt for a given line of text using the Gemini API.
 * This function includes a retry mechanism to handle transient server errors.
 * @param text The line of script to generate a prompt for.
 * @returns A promise that resolves to a string containing the visual prompt.
 */
export const generatePromptForText = async (text: string): Promise<string> => {
  if (!API_KEY) {
    console.warn("Gemini API key not configured, using basic prompt as fallback.");
    return `A cinematic shot related to: ${text}`;
  }

  const MAX_RETRIES = 3;
  const INITIAL_DELAY = 1000; // 1 second

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    try {
      const response = await ai.models.generateContent({
          model: 'gemini-2.5-flash',
          contents: `Generate a short, one-sentence visual prompt for an AI image/video generator based on this line of script: "${text}"`,
          config: {
              systemInstruction: 'You are an AI assistant that generates a short, one-sentence visual prompt for an AI image/video generator based on a line of script. The prompt should be descriptive and cinematic. Do not add any extra formatting or quotes around the prompt.',
          }
      });
      
      const prompt = response.text.trim();

      if (!prompt) {
        console.warn("Gemini returned an empty prompt, using fallback.");
        return `A cinematic shot related to: ${text}`;
      }
      // Clean up any potential quotes
      return prompt.replace(/^["']|["']$/g, '');

    } catch (error) {
      console.error(`Error on attempt ${attempt} calling Gemini API for prompt generation:`, error);
      if (attempt === MAX_RETRIES) {
        // All retries failed, use fallback.
        console.error("All prompt generation attempts failed. Using fallback.");
        return `A cinematic shot related to: ${text}`;
      }
      // Wait with exponential backoff before retrying
      const delay = INITIAL_DELAY * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  // This should not be reached due to the loop logic, but serves as a final fallback.
  return `A cinematic shot related to: ${text}`;
};